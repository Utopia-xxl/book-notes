# 第一部分 作用域和闭包

## 第1章 作用域是什么

### 1.1 编译原理

javaScript被归类为“动态”或“解释执行”语言。与传统的编译语言不同，它并不是提前编译的，因此也不能将编译结果在分布式系统中进行移植。

传统的编译语言，一般一段源代码在执行之前会经历三个步骤，统称为“编译”

- 分词/词法分析(Tokenizing/Lexing)

  将一条条代码分解成有意义的代码块，这些代码块被称为词法单元（token），如 var a = 2，就会被分解为var、a、=、2

- 解析/语法分析

  将拆分的词法转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。称为抽象语法树（AST）

- 代码生成

  将上述的AST转换为可执行代码

JavaScript引擎比传统的编译语言的处理要复杂得多，因为JavaScript不会提前编译好，所以不会给JavaScript大量的时间来进行优化，大部分编译发生在代码执行的前几微秒，所以JavaScript引擎用尽各种办法进行优化来保证性能最佳

### 1.2 理解作用域

#### 1.2.1 理解作用域的重要角色

- 引擎

  从头到尾负责整个JavaScript程序的编译及执行过程

- 编译器

  引擎的好朋友之一，负责语法分析及代码生成等脏活累活

- 作用域

  引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查 询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

## 第2章 词法作用域

### 2.1词法阶段

作用域是可以嵌套的,当查找一个变量时,如果没能查询到,会依次向上层作用域查询,直到找到变量为止。

作用域查找会在找到第一个匹配到标识符时停止。在多层的嵌套作用域中可以有同名的标识符，因此就不能访问到外层同名的变量。这就叫做遮蔽效应

解决：全局变量会自动成为全局对象的属性，因此可以通过间接地访问，如（window.a）

### 2.2 欺骗词法

evel(...) 函数可以接受一个字符串为参数，并将其中的内容视为原本就在的

```js
function foo(str, a) {
	eval( str ); // 欺骗！
	console.log( a, b );
}
var b = 2;
foo( "var b = 3;", 1 ); // 1, 3
```

eval(..) 调用中的 "var b = 3;" 这段代码会被当作本来就在那里一样来处理。由于那段代 码声明了一个新的变量 b，因此它对已经存在的 foo(..) 的词法作用域进行了修改。事实 上，和前面提到的原理一样，这段代码实际上在 foo(..) 内部创建了一个变量 b，并遮蔽 了外部（全局）作用域中的同名变量。

## 第3章 函数作用域和块作用域

能够隐藏变量，防止全局污染

有利于编译器进行垃圾回收

## 第4章 提升

```js
var a = 2;
```

这虽然只是一行代码，但实际上编译器会进行两步操作，JavaScript 实际上会将其看成两个 声明：var a; 和 a = 2;。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在 原地等待执行阶段。

